[
  {
    "instance_id": "astropy__astropy-11693",
    "patch": "diff --git a/astropy/wcs/wcsapi/fitswcs.py b/astropy/wcs/wcsapi/fitswcs.py\n--- a/astropy/wcs/wcsapi/fitswcs.py\n+++ b/astropy/wcs/wcsapi/fitswcs.py\n@@ -323,7 +323,11 @@ def pixel_to_world_values(self, *pixel_arrays):\n         return world[0] if self.world_n_dim == 1 else tuple(world)\n\n     def world_to_pixel_values(self, *world_arrays):\n-        pixel = self.all_world2pix(*world_arrays, 0)\n+        try:\n+            pixel = self.all_world2pix(*world_arrays, 0)\n+        except NoConvergence:\n+            warnings.warn(f\"'WCS.all_world2pix' failed to converge to the requested accuracy.\")\n+            pixel = self.low_accuracy_world2pix(*world_arrays, 0)\n         return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)\n\n     @property"
  },
  {
    "instance_id": "astropy__astropy-12057",
    "patch": "diff --git a/astropy/nddata/nduncertainty.py b/astropy/nddata/nduncertainty.py\n--- a/astropy/nddata/nduncertainty.py\n+++ b/astropy/nddata/nduncertainty.py\n@@ -688,6 +688,27 @@ class StdDevUncertainty(_VariancePropagationMixin, NDUncertainty):\n         new_unit = None if self.unit is None else self.unit ** (1 / 2)\n         return cls(new_array, unit=new_unit)\n \n+    def _convert_to_variance(self):\n+        new_array = None if self.array is None else self.array ** 2\n+        new_unit = None if self.unit is None else self.unit ** 2\n+        return VarianceUncertainty(new_array, unit=new_unit)\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        new_array = None if var_uncert.array is None else var_uncert.array ** (1 / 2)\n+        new_unit = None if var_uncert.unit is None else var_uncert.unit ** (1 / 2)\n+        return cls(new_array, unit=new_unit)\n+\n \n class VarianceUncertainty(_VariancePropagationMixin, NDUncertainty):\n     \"\"\"\n@@ -754,6 +775,13 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n         return value ** 2\n \n+    def _convert_to_variance(self):\n+        return self\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        return var_uncert\n+\n \n def _inverse(x):\n     \"\"\"Just a simple inverse for use in the InverseVariance\"\"\"\n@@ -853,3 +881,14 @@ def _propagate_divide(self, other_uncert, result_data, correlation):\n \n     def _data_unit_to_uncertainty_unit(self, value):\n         return 1 / value ** 2\n+\n+    def _convert_to_variance(self):\n+        new_array = None if self.array is None else 1 / self.array\n+        new_unit = None if self.unit is None else 1 / self.unit\n+        return VarianceUncertainty(new_array, unit=new_unit)\n+\n+    @classmethod\n+    def _convert_from_variance(cls, var_uncert):\n+        new_array = None if var_uncert.array is None else 1 / var_uncert.array\n+        new_unit = None if var_uncert.unit is None else 1 / var_uncert.unit\n+        return cls(new_array, unit=new_unit)"
  },
  {
    "instance_id": "astropy__astropy-12318",
    "patch": "diff --git a/astropy/modeling/physical_models.py b/astropy/modeling/physical_models.py\n--- a/astropy/modeling/physical_models.py\n+++ b/astropy/modeling/physical_models.py\n@@ -36,6 +36,7 @@ class BlackBody(Fittable1DModel):\n \n     Notes\n     -----\n+    The `scale` parameter must be dimensionless or convertible to dimensionless.\n \n     Model formula:\n \n@@ -65,6 +66,8 @@ class BlackBody(Fittable1DModel):\n     from astropy.units import si\n \n     _parameter_units = {\"temperature\": u.K}\n+    _output_units = u.erg / (u.cm ** 2 * u.s * u.Hz * u.sr)\n+\n     inputs = (\"x\",)\n     outputs = (\"y\",)\n \n@@ -84,6 +87,11 @@ class BlackBody(Fittable1DModel):\n                             'SLAM': u.erg / (u.cm ** 2 * u.s * u.AA * u.sr)}\n \n     def __init__(self, *args, **kwargs):\n+        scale = kwargs.get('scale', None)\n+\n+        if hasattr(scale, 'unit') and not scale.unit.is_dimensionless():\n+            kwargs['scale'] = scale.to_value(u.dimensionless_unscaled)\n+\n         super().__init__(*args, **kwargs)\n \n     def evaluate(self, x, temperature, scale):\n@@ -165,8 +173,15 @@ def evaluate(self, x, temperature, scale):\n         # Calculate blackbody flux\n         bb_nu = 2.0 * const.h * freq ** 3 / (const.c ** 2 * boltzm1) / u.sr\n \n+        if self.output_units == self._native_output_units['SLAM']:\n+            y = scale * bb_nu.to(self._output_units, u.spectral_density(freq))\n+        else:\n+            y = scale * bb_nu.to(self._output_units, u.spectral_density(freq)) * np.pi\n+\n         if self.scale.unit is not None:\n-            y = scale * bb_nu.to(self.scale.unit, u.spectral_density(freq))\n+            # during fitting, scale will be passed without units\n+            # but we still need to convert to dimensionless unscaled\n+            scale = u.Quantity(scale, self.scale.unit).to_value(u.dimensionless_unscaled)\n         else:\n             y = scale * bb_nu.to(u.Unit(self.scale.value), u.spectral_density(freq))\n \n@@ -182,11 +197,19 @@ def input_units(self):\n     # The input units are those of the 'x' value, which should always be\n     # Hz. Because we do this, and because input_units_allow_dimensionless\n     # is set to True, dimensionless values are assumed to be in Hz.\n-    return {self.inputs[0]: u.Hz}\n+    if self._output_units == self._native_output_units['SNU']:\n+        return {self.inputs[0]: u.Hz}\n+    else:\n+        return {self.inputs[0]: u.AA}\n \n     def _parameter_units_for_data_units(self, inputs_unit, outputs_unit):\n         return {\"temperature\": u.K}\n \n+@property\n+def output_units(self):\n+    \"\"\"The output units for the evaluate method.\"\"\"\n+    return self._output_units\n+\n     @property\n     def bolometric_flux(self):\n         \"\"\"Bolometric flux.\"\"\"\ndiff --git a/astropy/modeling/tests/test_physical_models.py b/astropy/modeling/tests/test_physical_models.py\n--- a/astropy/modeling/tests/test_physical_models.py\n+++ b/astropy/modeling/tests/test_physical_models.py"
  },
  {
    "instance_id": "astropy__astropy-12544",
    "patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -242,8 +242,9 @@ def read_table_fits(input, hdu=None, astropy_native=False, memmap=False,\n         cols = _decode_mixins(tbl)\n         cols = [(name, col) for name, col in cols.items()]\n         masked = any(isinstance(col, _MaskedColumn) for name, col in cols)\n+        mask_data = mask_invalid and not memmap\n         for name, col in cols:\n-            if masked:\n+            if mask_data:\n                 data[name] = col.data\n             else:\n                 data[name] = col"
  },
  {
    "instance_id": "astropy__astropy-12825",
    "patch": "diff --git a/astropy/table/column.py b/astropy/table/column.py\n--- a/astropy/table/column.py\n+++ b/astropy/table/column.py\n@@ -340,7 +340,9 @@ class ColumnInfo(BaseColumnInfo):\n     This is required when the object is used as a mixin column within a table,\n     but can be used as a general way to store meta information.\n     \"\"\"\n-    attrs_from_parent = BaseColumnInfo.attr_names\n+    attr_names = BaseColumnInfo.attr_names | {'groups'}\n+    _attrs_no_copy = BaseColumnInfo._attrs_no_copy | {'groups'}\n+    attrs_from_parent = attr_names\n     _supports_indexing = True\n \n     def new_like(self, cols, length, metadata_conflicts='warn', name=None):\ndiff --git a/astropy/table/groups.py b/astropy/table/groups.py\n--- a/astropy/table/groups.py\n+++ b/astropy/table/groups.py\n@@ -214,7 +214,7 @@ def __len__(self):\n class ColumnGroups(BaseGroups):\n     def __init__(self, parent_column, indices=None, keys=None):\n         self.parent_column = parent_column  # parent Column\n-        self.parent_table = parent_column.parent_table\n+        self.parent_table = parent_column.info.parent_table\n         self._indices = indices\n         self._keys = keys\n \n@@ -238,7 +238,8 @@ def keys(self):\n             return self._keys\n \n     def aggregate(self, func):\n-        from .column import MaskedColumn\n+        from .column import MaskedColumn, Column\n+        from astropy.utils.compat import NUMPY_LT_1_20\n \n         i0s, i1s = self.indices[:-1], self.indices[1:]\n         par_col = self.parent_column\n@@ -248,6 +249,15 @@ def aggregate(self, func):\n         mean_case = func is np.mean\n         try:\n             if not masked and (reduceat or sum_case or mean_case):\n+                # For numpy < 1.20 there is a bug where reduceat will fail to\n+                # raise an exception for mixin columns that do not support the\n+                # operation. For details see:\n+                # https://github.com/astropy/astropy/pull/12825#issuecomment-1082412447\n+                # Instead we try the function directly with a 2-element version\n+                # of the column\n+                if NUMPY_LT_1_20 and not isinstance(par_col, Column) and len(par_col) > 0:\n+                    func(par_col[[0, 0]])\n+\n                 if mean_case:\n                     vals = np.add.reduceat(par_col, i0s) / np.diff(self.indices)\n                 else:\n@@ -256,17 +266,18 @@ def aggregate(self, func):\n                     vals = func.reduceat(par_col, i0s)\n             else:\n                 vals = np.array([func(par_col[i0: i1]) for i0, i1 in zip(i0s, i1s)])\n+            out = par_col.__class__(vals)\n         except Exception as err:\n-            raise TypeError(\"Cannot aggregate column '{}' with type '{}'\"\n-                            .format(par_col.info.name,\n-                                    par_col.info.dtype)) from err\n-\n-        out = par_col.__class__(data=vals,\n-                                name=par_col.info.name,\n-                                description=par_col.info.description,\n-                                unit=par_col.info.unit,\n-                                format=par_col.info.format,\n-                                meta=par_col.info.meta)\n+            raise TypeError(\"Cannot aggregate column '{}' with type '{}': {}\"\n+                            .format(par_col.info.name, par_col.info"
  },
  {
    "instance_id": "astropy__astropy-12842",
    "patch": "diff --git a/astropy/time/core.py b/astropy/time/core.py\n--- a/astropy/time/core.py\n+++ b/astropy/time/core.py\n@@ -220,7 +220,20 @@ def _represent_as_dict(self, attrs=None):\n         \"\"\"\n         map = super()._represent_as_dict(attrs=attrs)\n \n-        # TODO: refactor these special cases into the TimeFormat classes?\n+        # The datetime64 format requires special handling for ECSV (see #12840).\n+        # The `value` has numpy dtype datetime64 but this is not an allowed\n+        # datatype for ECSV. Instead convert to a string representation.\n+        if (self._serialize_context == 'ecsv'\n+                and map['format'] == 'datetime64'\n+                and 'value' in map):\n+            map['value'] = map['value'].astype('U')\n+\n+        # The datetime format is serialized as ISO with no loss of precision.\n+        if map['format'] == 'datetime' and 'value' in map:\n+            map['value'] = np.vectorize(lambda x: x.isoformat())(map['value'])\n+\n+        return map\n+\n \n         # The datetime64 format requires special handling for ECSV (see #12840).\n         # The `value` has numpy dtype datetime64 but this is not an allowed"
  },
  {
    "instance_id": "astropy__astropy-12880",
    "patch": "diff --git a/astropy/io/ascii/ecsv.py b/astropy/io/ascii/ecsv.py\n--- a/astropy/io/ascii/ecsv.py\n+++ b/astropy/io/ascii/ecsv.py\n@@ -129,10 +129,15 @@ def get_cols(self, lines):\n         match = re.match(ecsv_header_re, lines[0].strip(), re.VERBOSE)\n         if not match:\n             raise core.InconsistentTableError(no_header_msg)\n-        # ecsv_version could be constructed here, but it is not currently used.\n+\n+        # Construct ecsv_version for backwards compatibility workarounds.\n+        self.ecsv_version = tuple(int(v or 0) for v in match.groups())\n \n         try:\n             header = meta.get_header_from_yaml(lines)\n+            # ECSV version <= 0.9 did not strictly follow the ECSV standard datatypes.\n+            # Allow these files to be read for backwards compatibility.\n+            self.ecsv_old_version = self.ecsv_version <= (0, 9, 0)\n         except ValueError as err:\n             raise core.InconsistentTableError(f'Failed to read YAML header: {err}')\n \n@@ -175,7 +180,7 @@ def get_cols(self, lines):\n \n             col.dtype = header_cols[col.name]['datatype']\n             # Require col dtype to be a valid ECSV datatype. However, older versions\n-            # of astropy writing ECSV version 0.9 and earlier had inadvertently allowed\n+            # of astropy writing ECSV version <= 0.9 had inadvertently allowed\n             # numpy datatypes like datetime64 or object or python str, which are not in the ECSV standard.\n             # For back-compatibility with those existing older files, allow reading with no error.\n             if col.dtype not in ECSV_DATATYPES and self.ecsv_version > (0, 9, 0):"
  },
  {
    "instance_id": "astropy__astropy-12962",
    "patch": "diff --git a/astropy/nddata/ccddata.py b/astropy/nddata/ccddata.py\n--- a/astropy/nddata/ccddata.py\n+++ b/astropy/nddata/ccddata.py\n@@ -270,8 +270,8 @@ def uncertainty(self, value):\n             self._uncertainty = value\n\n     def to_hdu(self, hdu_mask='MASK', hdu_uncertainty='UNCERT',\n-               hdu_flags=None, wcs_relax=True,\n-               key_uncertainty_type='UTYPE', as_image_hdu=False):\n+               hdu_flags=None, wcs_relax=True, key_uncertainty_type='UTYPE',\n+               as_image_hdu_only=False):\n         \"\"\"Creates an HDUList object from a CCDData object.\n\n         Parameters\n@@ -298,11 +298,11 @@ def to_hdu(self, hdu_mask='MASK', hdu_uncertainty='UNCERT',\n\n             .. versionadded:: 3.1\n\n-        as_image_hdu : bool\n+        as_image_hdu_only : bool\n             If this option is `True`, the first item of the returned\n-            `~astropy.io.fits.HDUList` is a `~astropy.io.fits.ImageHDU`, instead\n-            of the default `~astropy.io.fits.PrimaryHDU`.\n+            `~astropy.io.fits.HDUList` will have `~astropy.io.fits.ImageHDU`\n+            containing data from the `CCDData` object, without a preceding\n+            `~astropy.io.fits.PrimaryHDU`.\n \n         Raises\n         ------\n@@ -350,7 +350,10 @@ def to_hdu(self, hdu_mask='MASK', hdu_uncertainty='UNCERT',\n             wcs_header = self.wcs.to_header(relax=wcs_relax)\n             header.extend(wcs_header, useblanks=False, update=True)\n\n-        if as_image_hdu:\n+        if as_image_hdu_only:\n             hdus = [fits.ImageHDU(self.data, header)]\n+        else:\n+            hdus = [fits.PrimaryHDU(),\n+                    fits.ImageHDU(self.data, header)]\n\n         else:\n             hdus = [fits.PrimaryHDU(self.data, header)]\n@@ -677,8 +680,8 @@ def fits_ccddata_reader(filename, hdu=0, unit=None, hdu_uncertainty='UNCERT',\n\n def fits_ccddata_writer(\n         ccd_data, filename, hdu_mask='MASK', hdu_uncertainty='UNCERT',\n-        hdu_flags=None, key_uncertainty_type='UTYPE', as_image_hdu=False,\n+        hdu_flags=None, key_uncertainty_type='UTYPE', as_image_hdu_only=False,\n         **kwd):\n     \"\"\"\n     Write CCDData object to FITS file.\n@@ -702,10 +705,10 @@ def fits_ccddata_writer(\n\n         .. versionadded:: 3.1\n\n-    as_image_hdu : bool\n-        If this option is `True`, the first item of the returned\n-        `~astropy.io.fits.HDUList` is a `~astropy.io.fits.ImageHDU`, instead of\n-        the default `~astropy.io.fits.PrimaryHDU`.\n+    as_image_hdu_only : bool\n+        If this option is `True`, the returned `~astropy.io.fits.HDUList`\n+        will have `~astropy.io.fits.ImageHDU` containing data from the\n+        `CCDData` object, without a preceding `~astropy.io.fits.PrimaryHDU`.\n\n     kwd :\n         All additional keywords are passed to :py:mod:`astropy.io.fits`"
  },
  {
    "instance_id": "astropy__astropy-13032",
    "patch": "diff --git a/astropy/modeling/bounding_box.py b/astropy/modeling/bounding_box.py\n--- a/astropy/modeling/bounding_box.py\n+++ b/astropy/modeling/bounding_box.py\n@@ -694,6 +694,12 @@ def _validate_dict(self, bounding_box: dict):\n         for key, value in bounding_box.items():\n             self[key] = value\n \n+    @property\n+    def _available_input_index(self):\n+        model_input_index = [self._get_index(_input) for _input in self._model.inputs]\n+\n+        return [_input for _input in model_input_index if _input not in self._ignored]\n+\n     def _validate_sequence(self, bounding_box, order: str = None):\n         \"\"\"Validate passing tuple of tuples representation (or related) and setting them.\"\"\"\n         order = self._get_order(order)\n@@ -703,7 +709,7 @@ def _validate_sequence(self, bounding_box, order: str = None):\n             bounding_box = bounding_box[::-1]\n \n         for index, value in enumerate(bounding_box):\n-            self[index] = value\n+            self[self._available_input_index[index]] = value\n \n     @property\n     def _n_inputs(self) -> int:\n@@ -727,7 +733,7 @@ def _validate_iterable(self, bounding_box, order: str = None):\n     def _validate(self, bounding_box, order: str = None):\n         \"\"\"Validate and set any representation\"\"\"\n         if self._n_inputs == 1 and not isinstance(bounding_box, dict):\n-            self[0] = bounding_box\n+            self[self._available_input_index[0]] = bounding_box\n         else:\n             self._validate_iterable(bounding_box, order)\n \n@@ -751,7 +757,7 @@ def validate(cls, model, bounding_box,\n             order = bounding_box.order\n             if _preserve_ignore:\n                 ignored = bounding_box.ignored\n-            bounding_box = bounding_box.intervals\n+            bounding_box = bounding_box.named_intervals\n \n         new = cls({}, model, ignored=ignored, order=order)\n         new._validate(bounding_box)"
  },
  {
    "instance_id": "astropy__astropy-13033",
    "patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -79,9 +79,10 @@ class BaseTimeSeries(QTable):\n                 return\n\n             elif self.colnames[:len(required_columns)] != required_columns:\n-                raise ValueError(\"{} object is invalid - expected '{}' \"\n-                                 \"as the first column{} but found '{}'\"\n-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n+                raise ValueError(\"{} object is invalid - expected {} \"\n+                                 \"as the first column{} but found {}\"\n+                                 .format(self.__class__.__name__, as_scalar_or_list_str(required_columns),\n+                                         plural, as_scalar_or_list_str(self.colnames[:len(required_columns)])))\n\n             if (self._required_columns_relax\n                     and self._required_columns == self.colnames[:len(self._required_columns)]):"
  },
  {
    "instance_id": "astropy__astropy-13068",
    "patch": "diff --git a/astropy/time/core.py b/astropy/time/core.py\n--- a/astropy/time/core.py\n+++ b/astropy/time/core.py\n@@ -597,6 +597,10 @@ class TimeBase():\n         self._time.init_from_val(*copy.deepcopy((val, val2)))\n \n     def __init__(self, val1, val2=None, val2_is_precision=False, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, from_stdtime=False, copy=False):\n+        if precision is not None:\n+            if not isinstance(precision, int) or precision < 0 or precision > 9:\n+                raise ValueError('precision attribute must be an int between '\n+                                 '0 and 9')\n+\n         if copy:\n             self.cache = None\n             self.info = copy.deepcopy(self.info)\ndiff --git a/astropy/time/formats.py b/astropy/time/formats.py\n--- a/astropy/time/formats.py\n+++ b/astropy/time/formats.py\n@@ -231,6 +231,11 @@ def jd2_filled(self):\n         return np.nan_to_num(self.jd2) if self.masked else self.jd2\n \n     @property\n+    def _precision(self):\n+        return self._time.precision\n+\n+    @_precision.setter\n     def precision(self, val):\n+        self._time.precision = val\n+\n         return self._precision"
  },
  {
    "instance_id": "astropy__astropy-13073",
    "patch": "diff --git a/astropy/io/ascii/core.py b/astropy/io/ascii/core.py\n--- a/astropy/io/ascii/core.py\n+++ b/astropy/io/ascii/core.py\n@@ -1032,7 +1032,7 @@ def _validate_and_copy(col, converters):\n             # Don't allow list-like things that dtype accepts\n             assert type(converters) is type\n             converters = [numpy.dtype(converters)]\n-        except (AssertionError, TypeError):\n+        except (AssertionError, TypeError, ValueError):\n             pass\n \n         converters_out = []\n@@ -1043,7 +1043,7 @@ def _validate_and_copy(col, converters):\n                 except TypeError as err:\n                     if str(err).startswith('cannot unpack'):\n                         converter_func, converter_type = convert_numpy(converter)\n-                    else:\n+                    elif not issubclass(converter, NoType):\n                         raise\n                 if not issubclass(converter_type, NoType):\n                     raise ValueError('converter_type must be a subclass of NoType')"
  }
]